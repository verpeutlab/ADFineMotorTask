# -*- coding: utf-8 -*-
"""Fine Motor Analysis Code

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TZzZ_f2TU7IYHicQW58Ivrt2Evh3s5Jm

# **1.** Mount Google Drive
"""

from google.colab import drive
drive.mount('/content/drive')

"""# **2.** Add necessary packages"""

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns
sns.set_style("whitegrid")
import pandas as pd
import matplotlib.ticker as plticker

!pip install pingouin
import pingouin as pg

from scipy import stats

!pip install bioinfokit
from bioinfokit.analys import get_data, stat

!pip install heatmapz
from heatmap import heatmap, corrplot
from scipy import stats
from scipy.stats import f_oneway
import statsmodels.api as sm
from statsmodels.formula.api import ols
from statsmodels.stats.multicomp import pairwise_tukeyhsd
from statsmodels.stats.anova import anova_lm
from statsmodels.formula.api import mixedlm
from statsmodels.stats.anova import AnovaRM
from scipy.stats import zscore
from scipy.integrate import simps

"""# **3.** Read spreadsheet and view"""

from google.colab import auth
auth.authenticate_user()

import gspread
from google.auth import default
creds, _ = default()

gc = gspread.authorize(creds)

worksheet = gc.open('tr per min').worksheet("Sheet1")

# get_all_values gives a list of rows.
df = worksheet.get_all_values()
print(df)

# Convert to a DataFrame and render.
import pandas as pd
pd.DataFrame.from_records(df)

"""# Figure 2b - total reaches over time during training"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

plt.rcParams['pdf.fonttype'] = 42 #to work with in illustrator
plt.rcParams['ps.fonttype'] = 42 #to work with in illustrator

from gspread_dataframe import get_as_dataframe
sheet = gc.open('jeannereaching').worksheet("Sheet1")
df = get_as_dataframe(sheet)

# Ensure the data is sorted by AnimalID and Day
df = df.sort_values(by=['AnimalID', 'Day'])

# Filter out rows with NaN in AnimalID
df = df.dropna(subset=['AnimalID'])

# Get unique AnimalIDs
subjects = df['AnimalID'].unique()


# Convert 'Day' column to numeric, handling errors
df['Day'] = pd.to_numeric(df['Day'], errors='coerce')  # 'coerce' will replace non-numeric values with NaN

# Drop rows with NaN values in 'Day' column
df = df.dropna(subset=['Day'])
# Define specific colors for each subject
#subject_colors = {
 #   'AN1C1': 'black',
  #  'AN2C1': 'dimgray',
   # 'AN1C2': 'gray',
    #'AN2C2': 'darkgray',
    #'AN1C3': 'silver',
    #'AN2C3': 'lightgray'
#}

subject_colors = {
    'AN1C1': 'black', #Rat1
    'AN2C1': 'slategrey', #Rat2
    'AN1C2': 'orange', #animal removed, #Rat3
    'AN2C2': 'silver', #Rat4
    'AN1C3': 'lightcoral', #Rat5
    'AN2C3': 'cornflowerblue' #Rat6
}

# Plotting
plt.figure(figsize=(10, 6))

for subject in subjects:
    subject_data = df[df['AnimalID'] == subject]
    color = subject_colors.get(subject, 'black')  # Default to 'black' if subject not in the dictionary
    plt.plot(subject_data['Day'], subject_data['Reaches'], marker='o', label=f'Animal {subject}', color=color)

# Add a gray overlay between days 4.5 and 5.5
plt.axvspan(4.5, 5.5, color='gray', alpha=0.5, label='Day 5 Highlight')

# Adding titles and labels
plt.title('Days to reach training criteria', fontsize=20)
plt.xlabel('Day', fontsize=16)
plt.ylabel('Reaches', fontsize=16)
plt.legend(title='Subjects', loc='center left', bbox_to_anchor=(1, 0.5))
sns.despine()
plt.grid(False)

# Set x-axis ticks to label every day
days = df['Day'].unique()
plt.xticks(days)

# Customize tick marks (dashes) and increase font size
plt.tick_params(axis='x', which='both', direction='in', length=10, labelsize=14)  # Dashes and larger font on x-axis
plt.tick_params(axis='y', which='both', direction='in', length=10, labelsize=14)  # Dashes and larger font on y-axis


# Adjust legend for barplot with colors matching the barplot palette
handles, labels = plt.gca().get_legend_handles_labels()
plt.legend(
    handles=handles[:6],
    labels=labels[:6],
    #title='Category',
    loc='upper left',  # Position the legend inside the plot
    bbox_to_anchor=(0, 1),  # Adjust position inside the plot
    frameon=False,  # Remove legend border
    fontsize=12     # Font size for legend
)

# Display the plot
plt.tight_layout()  # Adjust layout to make room for the legend

plt.show()

def repeated_measures_anova(data, dv, within, subject):
    """
    Perform repeated measures ANOVA.

    Parameters:
    data (DataFrame): Input DataFrame containing the data.
    dv (str): Name of the dependent variable (column name).
    within (str): Name of the within-subject factor (repeated component).
    subject (str): Name of the subject identifier.

    Returns:
    res (DataFrame): ANOVA results.
    """
    res = pg.rm_anova(dv=dv, within=within, subject=subject, data=data)
    return res

res = repeated_measures_anova(df, 'Reaches', 'Day', 'AnimalID')
print(res)

"""# Figure 2c - total reaches over time

"""

import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.cm import get_cmap

plt.rcParams['pdf.fonttype'] = 42 #to work with in illustrator
plt.rcParams['ps.fonttype'] = 42 #to work with in illustrator

from gspread_dataframe import get_as_dataframe
sheet = gc.open('finemotorupdated').worksheet("AllData")
df = get_as_dataframe(sheet)

# get_all_values gives a list of rows.
df = worksheet.get_all_values()
print(df)
df = get_as_dataframe(sheet)

# Clean data: Drop rows with NaN values in 'Rat' column and strip whitespace
df = df.dropna(subset=['Rat'])
df['Rat'] = df['Rat'].str.strip()

# Plotting
fig, ax = plt.subplots(figsize=(10, 6))

# Extract unique animals (rats) for plotting
rats = df['Rat'].unique()

# Define colors for each rat
colors = ['black', 'slategrey', 'silver', 'lightcoral', 'cornflowerblue']  # Adjust as needed for more rats

# Plot lines for each rat with a different color
for i, rat in enumerate(rats):
    rat_data = df[df['Rat'] == rat]
    color = colors[i % len(colors)]  # Use modulo to cycle through the color list
    ax.plot(rat_data['Day'], rat_data['Total_per_Day'], marker='o', linestyle='-', color=color, label=rat)

# Customizing the plot
ax.set_ylabel('Total Reaches', fontsize=16)
ax.set_title('Individual total reaches', fontsize=20)

# Secondary x-axis with bowl categories below the primary x-axis
secax = ax.twiny()

# Define the days and corresponding bowl categories (this makes the labels only on the centered days)
days = df['Day'].unique()
bowl_categories = ['Plain' if day == 2 else 'Less' if day == 5 else 'Plinko' if day == 8 else '' for day in days]

# Set ticks and labels for the secondary x-axis
secax.set_xticks(days)
secax.set_xticklabels(bowl_categories)

# Add vertical lines between specific secondary axis labels
secax.axvline(x=3.5, color='gray', linestyle='--', linewidth=1)  # Between days 3 and 4
secax.axvline(x=6.5, color='gray', linestyle='--', linewidth=1)  # Between days 6 and 7

# Adjust the position of the secondary x-axis labels to align below the Day x-axis
secax.xaxis.set_ticks_position('bottom')
secax.xaxis.set_label_position('bottom')
secax.tick_params(axis='x', which='both', direction='out', pad=35, labelbottom=True)  # Adjust pad for proper alignment

# Remove the secondary x-axis spines
secax.spines['top'].set_visible(False)
secax.spines['bottom'].set_visible(False)

# Hide the primary x-axis ticks and labels
#ax.xaxis.set_ticks_position('none')

# Remove gridlines from both x-axes
ax.grid(False)
secax.grid(False)

# Adjust layout to ensure proper alignment of secondary x-axis labels at the bottom
plt.subplots_adjust(bottom=0.25)  # Adjust the bottom margin as needed

# Increase font size of primary x-axis and y-axis tick labels
ax.tick_params(axis='x', direction='out', labelsize=14)  # Primary x-axis ticks
ax.tick_params(axis='y', direction='out', labelsize=14)  # Primary y-axis ticks

# Set outward ticks for the secondary x-axis
secax.tick_params(axis='x', direction='out', labelsize=14)  # Secondary x-axis ticks
secax.tick_params(axis='y', direction='out', labelsize=14)  # Secondary x-axis ticks

# Move the secondary x-axis labels below the Day x-axis title
secax.xaxis.set_label_coords(0.5, -0.2)  # Adjust the y-coordinate as needed

# Align secondary x-axis labels with primary x-axis ticks
secax.set_xlim(ax.get_xlim())
secax.set_ylim(ax.get_ylim())

plt.tight_layout()
sns.despine()
plt.grid(False)

# Add the legend
legend = ax.legend(
    loc='upper left',  # Position the legend inside the plot
    frameon=False,  # Remove legend border
    fontsize=10     # Adjust font size
)

# Set legend text colors to match the line colors
for text, line in zip(legend.get_texts(), legend.get_lines()):
    text.set_color(line.get_color())  # Match text color to line color


plt.show()

def repeated_measures_anova(data, dv, within, subject):
    """
    Perform repeated measures ANOVA.

    Parameters:
    data (DataFrame): Input DataFrame containing the data.
    dv (str): Name of the dependent variable (column name).
    within (str): Name of the within-subject factor (repeated component).
    subject (str): Name of the subject identifier.

    Returns:
    res (DataFrame): ANOVA results.
    """
    res = pg.rm_anova(dv=dv, within=within, subject=subject, data=data)
    return res

res = repeated_measures_anova(df, 'Total_per_Day', 'Day', 'Rat')
print(res)

def posthoc_test(data, dv, within, subject, correction='auto'):
    """
    Perform post-hoc test after repeated measures ANOVA.

    Parameters:
    data (DataFrame): Input DataFrame containing the data.
    dv (str): Name of the dependent variable (column name).
    within (str): Name of the within-subject factor (repeated component).
    subject (str): Name of the subject identifier.
    correction (str): Type of correction for multiple comparisons.
                     Can be 'auto', 'bonferroni', 'sidak', 'holm', 'fdr_bh', None.

    Returns:
    posthoc (DataFrame): Pairwise comparison results.
    """
    posthoc = pg.pairwise_ttests(dv=dv, within=within, subject=subject, data=data, correction=correction)
    return posthoc

posthoc = posthoc_test(df, 'Total_per_Day', 'Bowl', 'Rat', correction='bonferroni')
print(posthoc)

"""# Figure 3a Baseline BoxPlot for Total"""

#groupingboxplotsbybowl

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from gspread_dataframe import get_as_dataframe

# Set font type for compatibility with Illustrator
plt.rcParams['pdf.fonttype'] = 42
plt.rcParams['ps.fonttype'] = 42

# Load Google Sheet data
sheet = gc.open('finemotorupdated').worksheet("AllData")
all_data = get_as_dataframe(sheet, evaluate_formulas=True)

# Ensure 'Bowl' column is categorical with the desired order and clean any unexpected values
all_data['Bowl'] = pd.Categorical(all_data['Bowl'], categories=['plain', 'less', 'plinko'], ordered=True)

# Calculate the average 'Total_per_Day' per rat per bowl
all_data_avg = all_data.groupby(['Rat', 'Bowl'], as_index=False)['Total_per_Day'].mean()

# Check for any invalid or missing values in the 'Bowl' column
if all_data['Bowl'].isnull().any():
    print("Warning: Missing values detected in 'Bowl' column. Dropping rows with missing 'Bowl' values.")
    all_data = all_data.dropna(subset=['Bowl'])

# Create a boxplot
fig, ax = plt.subplots(figsize=(6, 7))


# Create boxplot
sns.boxplot(
    data=all_data_avg, x='Bowl', y='Total_per_Day', ax=ax, width=0.6,
    boxprops=dict(facecolor='white', linewidth=1),
    showfliers=False,  # Remove outliers from the boxplot
    medianprops=dict(color='black'),
    whiskerprops=dict(color='black'),
    capprops=dict(color='black')
)

# Overlay swarmplot
sns.swarmplot(
    data=all_data_avg, x='Bowl', y='Total_per_Day', ax=ax,
    color='black', alpha=0.7, size=6
)

# Remove grid lines
ax.grid(False)

# Set outward ticks for the secondary x-axis
secax.tick_params(axis='x', direction='out', labelsize=14)  # Secondary x-axis ticks
secax.tick_params(axis='y', direction='out', labelsize=14)  # Secondary x-axis ticks

# Set labels and title
ax.set_ylabel('Total Reaches', fontsize=12)
ax.set_title('Baseline total reaches day', fontsize=14)

# Remove grid lines
sns.despine()
plt.grid(False)
plt.ylim(0, 70)


plt.show()

from scipy.stats import f_oneway

data=all_data

def one_way_anova(data, dv, grouping_var):
    """
    Perform one-way ANOVA.

    Parameters:
    data (DataFrame): Input DataFrame containing the data.
    dv (str): Name of the dependent variable (e.g., 'Total_per_Day').
    grouping_var (str): Name of the grouping variable (e.g., 'Bowl').

    Returns:
    f_statistic (float): F-statistic value.
    p_value (float): p-value.
    """
    # Check if the grouping variable exists in the DataFrame
    if grouping_var not in data.columns:
        raise ValueError(f"The column '{grouping_var}' is not in the DataFrame")

    # Group data by the grouping variable and extract dependent variable values
    groups = [group[dv].values for _, group in data.groupby(grouping_var)]

    # Perform one-way ANOVA
    f_statistic, p_value = f_oneway(*groups)

    return f_statistic, p_value

def tukey_posthoc(data, dv, grouping_var):
    """
    Perform Tukey's HSD post hoc test after one-way ANOVA.

    Parameters:
    data (DataFrame): Input DataFrame containing the data.
    dv (str): Name of the dependent variable (e.g., 'Total_per_Day').
    grouping_var (str): Name of the grouping variable (e.g., 'Bowl').

    Returns:
    summary (DataFrame): A summary table of pairwise comparisons and p-values.
    """
    # Perform Tukey HSD post-hoc test
    tukey_result = pairwise_tukeyhsd(endog=data[dv], groups=data[grouping_var], alpha=0.05)

    # Return summary of the Tukey test
    return tukey_result.summary()

# Perform the one-way ANOVA
try:
    f_statistic, p_value = one_way_anova(all_data, 'Total_per_Day', 'Bowl')
    print("F-statistic:", f_statistic)
    print("p-value:", p_value)

    # If the ANOVA is significant, run the post-hoc test
    if p_value < 0.05:
        print("\nPost-hoc Test (Tukey HSD):")
        posthoc_results = tukey_posthoc(all_data, 'Total_per_Day', 'Bowl')
        print(posthoc_results)
    else:
        print("\nANOVA is not significant, no post-hoc test needed.")
except ValueError as e:
    print(e)

"""# Figure 3b Harmaline BoxPlot for Total"""

#groupingboxplotsbybowl

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from gspread_dataframe import get_as_dataframe

# Set font type for compatibility with Illustrator
plt.rcParams['pdf.fonttype'] = 42
plt.rcParams['ps.fonttype'] = 42

# Load Google Sheet data
sheet = gc.open('harmalineupdated').worksheet("Sheet1")
all_data = get_as_dataframe(sheet, evaluate_formulas=True)

# Ensure 'Bowl' column is categorical with the desired order and clean any unexpected values
all_data['Bowl'] = pd.Categorical(all_data['Bowl'], categories=['plain', 'less', 'plinko'], ordered=True)

# Check for any invalid or missing values in the 'Bowl' column
if all_data['Bowl'].isnull().any():
    print("Warning: Missing values detected in 'Bowl' column. Dropping rows with missing 'Bowl' values.")
    all_data = all_data.dropna(subset=['Bowl'])

# Create a boxplot
fig, ax = plt.subplots(figsize=(6, 7))

# Create boxplot
sns.boxplot(
    data=all_data, x='Bowl', y='Total_per_Day', ax=ax, width=0.6,
    boxprops=dict(facecolor='white', linewidth=1),
    showfliers=False,  # Remove outliers from the boxplot
    medianprops=dict(color='black'),
    whiskerprops=dict(color='black'),
    capprops=dict(color='black')
)

# Overlay swarmplot
sns.swarmplot(
    data=all_data, x='Bowl', y='Total_per_Day', ax=ax,
    color='dodgerblue', alpha=0.7, size=6
)

# Remove grid lines
ax.grid(False)

# Set outward ticks for the secondary x-axis
secax.tick_params(axis='x', direction='out', labelsize=14)  # Secondary x-axis ticks
secax.tick_params(axis='y', direction='out', labelsize=14)  # Secondary x-axis ticks

# Set labels and title
ax.set_ylabel('Total Reaches', fontsize=12)
ax.set_title('Harmaline total reaches day', fontsize=14)

# Remove grid lines
sns.despine()
plt.grid(False)


plt.show()

data=all_data

def one_way_anova(data, dv, grouping_var):
    """
    Perform one-way ANOVA.

    Parameters:
    data (DataFrame): Input DataFrame containing the data.
    dv (str): Name of the dependent variable (e.g., 'Total_per_Day').
    grouping_var (str): Name of the grouping variable (e.g., 'Bowl').

    Returns:
    f_statistic (float): F-statistic value.
    p_value (float): p-value.
    """
    # Check if the grouping variable exists in the DataFrame
    if grouping_var not in data.columns:
        raise ValueError(f"The column '{grouping_var}' is not in the DataFrame")

    # Group data by the grouping variable and extract dependent variable values
    groups = [group[dv].values for _, group in data.groupby(grouping_var)]

    # Perform one-way ANOVA
    f_statistic, p_value = f_oneway(*groups)

    return f_statistic, p_value

def tukey_posthoc(data, dv, grouping_var):
    """
    Perform Tukey's HSD post hoc test after one-way ANOVA.

    Parameters:
    data (DataFrame): Input DataFrame containing the data.
    dv (str): Name of the dependent variable (e.g., 'Total_per_Day').
    grouping_var (str): Name of the grouping variable (e.g., 'Bowl').

    Returns:
    summary (DataFrame): A summary table of pairwise comparisons and p-values.
    """
    # Perform Tukey HSD post-hoc test
    tukey_result = pairwise_tukeyhsd(endog=data[dv], groups=data[grouping_var], alpha=0.05)

    # Return summary of the Tukey test
    return tukey_result.summary()

# Perform the one-way ANOVA
try:
    f_statistic, p_value = one_way_anova(all_data, 'Total_per_Day', 'Bowl')
    print("F-statistic:", f_statistic)
    print("p-value:", p_value)

    # If the ANOVA is significant, run the post-hoc test
    if p_value < 0.05:
        print("\nPost-hoc Test (Tukey HSD):")
        posthoc_results = tukey_posthoc(all_data, 'Total_per_Day', 'Bowl')
        print(posthoc_results)
    else:
        print("\nANOVA is not significant, no post-hoc test needed.")
except ValueError as e:
    print(e)

"""# Figure 4a Baseline boxplots"""

#For control data

import gspread
from gspread_dataframe import get_as_dataframe
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

plt.rcParams['pdf.fonttype'] = 42 #to work with in illustrator
plt.rcParams['ps.fonttype'] = 42 #to work with in illustrator

worksheet = gc.open("finemotorupdated").worksheet('AllData')  # Specify the worksheet name

# Load the data into a pandas DataFrame
all_data = get_as_dataframe(worksheet, evaluate_formulas=True)

# Ensure the 'Bowl' column has the correct order
all_data['Bowl'] = pd.Categorical(all_data['Bowl'], categories=['plain', 'less', 'plinko'], ordered=True)

all_data_avg = all_data.groupby(['Rat', 'Bowl'], as_index=False)[['Success', 'Dropped', 'Failure']].mean()

# Melt the data for easier grouping in the plot
melted_data = all_data_avg.melt(id_vars=['Rat','Bowl'], value_vars=['Success', 'Dropped', 'Failure'],
                                var_name='Category', value_name='Count')

custom_palette = ['forestgreen', 'salmon', 'red',]  # Red, Blue, Green, Yellow

# Create the plot
plt.figure(figsize=(10, 6))
sns.barplot(
    data=melted_data,
    x='Bowl',
    y='Count',
    hue='Category',
    errorbar=('ci', 68),       # SEM
    palette=custom_palette,        # Placeholder palette; we'll override this
    alpha=0.6              # Slight transparency for bars
)

# Scatter points (black swarmplot)
sns.swarmplot(
    data=melted_data,
    x='Bowl',
    y='Count',
    hue='Category',
    dodge=True,      # Adjust position to match boxplot
    color='black',   # Black scatter points
    alpha=0.7,       # Slight transparency
    legend=False,
    size=5           # Adjust scatter size
)

# Adjust legend
plt.legend(title='Category', bbox_to_anchor=(1.05, 1), loc='upper left')

# Add labels and title
#plt.title('Boxplot with Swarmplot: Success, Dropped, and Failure Counts by Bowl', fontsize=14)
plt.xlabel('Bowl', fontsize=12)
plt.ylabel('Count', fontsize=12)

# Adjust legend for barplot with colors matching the barplot palette
handles, labels = plt.gca().get_legend_handles_labels()
plt.legend(
    handles=handles[:3],
    labels=labels[:3],
    #title='Category',
    loc='upper left',  # Position the legend inside the plot
    bbox_to_anchor=(0, 1),  # Adjust position inside the plot
    frameon=False,  # Remove legend border
    fontsize=12     # Font size for legend
)

# Remove gridlines
sns.despine()
plt.grid(False)

# Set y-axis limits
plt.ylim(0, 40)
plt.title("Baseline")

# Final adjustments
plt.tight_layout()


plt.show()

# Perform the Two-Way ANOVA (with interaction between Bowl and Category)
model = ols('Count ~ C(Bowl) * C(Category)', data=melted_data).fit()
anova_table = sm.stats.anova_lm(model, typ=2)

print("ANOVA Results:")
print(anova_table)

# If the p-value is significant, you can proceed with post-hoc tests
if anova_table['PR(>F)']['C(Bowl):C(Category)'] < 0.05:
    print("Significant interaction between Bowl and Category, performing post-hoc tests.")
    # Post-hoc tests can be performed here (e.g., Tukey HSD test)
else:
    print("No significant interaction between Bowl and Category.")

"""# Figure 4b Harmaline boxplots"""

#For harmaline data

import gspread
from gspread_dataframe import get_as_dataframe
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

plt.rcParams['pdf.fonttype'] = 42 #to work with in illustrator
plt.rcParams['ps.fonttype'] = 42 #to work with in illustrator

worksheet = gc.open("harmalineupdated").worksheet('Sheet1')  # Specify the worksheet name

# Load the data into a pandas DataFrame
all_data = get_as_dataframe(worksheet, evaluate_formulas=True)

# Ensure the 'Bowl' column has the correct order
all_data['Bowl'] = pd.Categorical(all_data['Bowl'], categories=['plain', 'less', 'plinko'], ordered=True)

# Melt the data for easier grouping in the plot
melted_data = all_data.melt(id_vars=['Bowl'], value_vars=['Success', 'Dropped', 'Failure'],
                            var_name='Category', value_name='Count')

custom_palette = ['forestgreen', 'salmon', 'red',]  # Red, Blue, Green, Yellow

# Create the plot
plt.figure(figsize=(10, 6))
sns.barplot(
    data=melted_data,
    x='Bowl',
    y='Count',
    hue='Category',
    errorbar=('ci', 68),       # SEM
    palette=custom_palette,        # Placeholder palette; we'll override this
    alpha=0.6              # Slight transparency for bars
)

# Scatter points (black swarmplot)
sns.swarmplot(
    data=melted_data,
    x='Bowl',
    y='Count',
    hue='Category',
    dodge=True,      # Adjust position to match boxplot
    color='black',   # Black scatter points
    alpha=0.7,       # Slight transparency
    legend=False,
    size=5           # Adjust scatter size
)

# Adjust legend
plt.legend(title='Category', bbox_to_anchor=(1.05, 1), loc='upper left')

# Add labels and title
#plt.title('Boxplot with Swarmplot: Success, Dropped, and Failure Counts by Bowl', fontsize=14)
plt.xlabel('Bowl', fontsize=12)
plt.ylabel('Count', fontsize=12)

# Adjust legend for barplot with colors matching the barplot palette
handles, labels = plt.gca().get_legend_handles_labels()
plt.legend(
    handles=handles[:3],
    labels=labels[:3],
    #title='Category',
    loc='upper left',  # Position the legend inside the plot
    bbox_to_anchor=(0, 1),  # Adjust position inside the plot
    frameon=False,  # Remove legend border
    fontsize=12     # Font size for legend
)
# Remove gridlines
sns.despine()
plt.grid(False)

# Set y-axis limits
plt.ylim(0, 40)
plt.title("Harmaline")

# Final adjustments
plt.tight_layout()


plt.show()

# Perform the Two-Way ANOVA (with interaction between Bowl and Category)
model = ols('Count ~ C(Bowl) * C(Category)', data=melted_data).fit()
anova_table = sm.stats.anova_lm(model, typ=2)

print("ANOVA Results:")
print(anova_table)

# If the p-value for interaction is significant, perform Tukey's HSD test
if anova_table['PR(>F)']['C(Bowl):C(Category)'] < 0.05:
    print("\nSignificant interaction between Bowl and Category, performing post-hoc test (Tukey HSD).")

    # Perform Tukey's HSD test
    tukey_result = pairwise_tukeyhsd(endog=melted_data['Count'],
                                     groups=melted_data['Bowl'].astype(str) + "_" + melted_data['Category'].astype(str),
                                     alpha=0.05)

    print("\nTukey HSD Post-hoc Test Results:")
    print(tukey_result.summary())
else:
    print("\nNo significant interaction between Bowl and Category. No post-hoc test needed.")

"""# Figure 4c Baseline boxplots"""

import gspread
from gspread_dataframe import get_as_dataframe
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

plt.rcParams['pdf.fonttype'] = 42 #to work with in illustrator
plt.rcParams['ps.fonttype'] = 42 #to work with in illustrator

worksheet = gc.open("finemotorupdated").worksheet('AllData')  # Specify the worksheet name

# Load the data into a pandas DataFrame
all_data = get_as_dataframe(worksheet, evaluate_formulas=True)

# Ensure 'Bowl' column is categorical with the desired order and clean any unexpected values
all_data['Bowl'] = pd.Categorical(all_data['Bowl'], categories=['plain', 'less', 'plinko'], ordered=True)

# Check for any invalid or missing values in the 'Bowl' column
if all_data['Bowl'].isnull().any():
    print("Warning: Missing values detected in 'Bowl' column. Dropping rows with missing 'Bowl' values.")
    all_data = all_data.dropna(subset=['Bowl'])

# Multiply value_vars by 100
value_vars = ['SuccessPerformance', 'DroppedPerformance', 'FailurePerformance']
all_data[value_vars] = all_data[value_vars] * 100
all_data_avg = all_data.groupby(['Rat', 'Bowl'], as_index=False)[value_vars].mean()

# Melt the data for easier grouping in the plot
melted_data = all_data_avg.melt(id_vars=['Bowl'], value_vars=value_vars,
                                var_name='Category', value_name='Count')

custom_palette = ['forestgreen', 'salmon', 'red',]  # Red, Blue, Green, Yellow

# Create the plot
plt.figure(figsize=(10, 6))
sns.barplot(
    data=melted_data,
    x='Bowl',
    y='Count',
    hue='Category',
    errorbar=('ci', 68),       # SEM
    palette=custom_palette,        # Placeholder palette; we'll override this
    alpha=0.6              # Slight transparency for bars
)

# Adjust boxplot colors manually to make the interior white
#for patch in boxplot.patches:
#    patch.set_facecolor('white')  # Set interior color to white
#    patch.set_edgecolor('black')  # Set border color to black


# Scatter points (black swarmplot)
sns.swarmplot(
    data=melted_data,
    x='Bowl',
    y='Count',
    hue='Category',
    dodge=True,      # Adjust position to match boxplot
    color='black',   # Black scatter points
    alpha=0.7,       # Slight transparency
    legend=False,
    size=5           # Adjust scatter size
)

# Adjust legend
plt.legend(title='Category', bbox_to_anchor=(1.05, 1), loc='upper left')

# Add labels and title
#plt.title('Boxplot with Swarmplot: Success, Dropped, and Failure Counts by Bowl', fontsize=14)
plt.xlabel('Bowl', fontsize=12)
plt.ylabel('Performance (%)', fontsize=12)

# Adjust legend for barplot with colors matching the barplot palette
handles, labels = plt.gca().get_legend_handles_labels()
plt.legend(
    handles=handles[:3],
    labels=labels[:3],
    #title='Category',
    loc='upper left',  # Position the legend inside the plot
    bbox_to_anchor=(0, 1),  # Adjust position inside the plot
    frameon=False,  # Remove legend border
    fontsize=12     # Font size for legend
)

# Remove gridlines
sns.despine()
plt.grid(False)

# Set y-axis limits
plt.ylim(0, 100)
plt.title("Baseline")

# Final adjustments
plt.tight_layout()


plt.show()

# Perform the Two-Way ANOVA (with interaction between Bowl and Category)
model = ols('Count ~ C(Bowl) * C(Category)', data=melted_data).fit()
anova_table = sm.stats.anova_lm(model, typ=2)

print("ANOVA Results:")
print(anova_table)

# If the p-value for interaction is significant, perform Tukey's HSD test
if anova_table['PR(>F)']['C(Bowl):C(Category)'] < 0.05:
    print("\nSignificant interaction between Bowl and Category, performing post-hoc test (Tukey HSD).")

    # Perform Tukey's HSD test
    tukey_result = pairwise_tukeyhsd(endog=melted_data['Count'],
                                     groups=melted_data['Bowl'].astype(str) + "_" + melted_data['Category'].astype(str),
                                     alpha=0.05)

    print("\nTukey HSD Post-hoc Test Results:")
    print(tukey_result.summary())
else:
    print("\nNo significant interaction between Bowl and Category. No post-hoc test needed.")

"""# Figure 4d Harmaline boxplots"""

import gspread
from gspread_dataframe import get_as_dataframe
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

plt.rcParams['pdf.fonttype'] = 42 #to work with in illustrator
plt.rcParams['ps.fonttype'] = 42 #to work with in illustrator

worksheet = gc.open("harmalineupdated").worksheet('Sheet1')  # Specify the worksheet name

# Load the data into a pandas DataFrame
all_data = get_as_dataframe(worksheet, evaluate_formulas=True)

# Ensure the 'Bowl' column has the correct order
all_data['Bowl'] = pd.Categorical(all_data['Bowl'], categories=['plain', 'less', 'plinko'], ordered=True)

# Multiply value_vars by 100
value_vars = ['SuccessPerformance', 'DroppedPerformance', 'FailurePerformance']
all_data[value_vars] = all_data[value_vars] * 100

# Melt the data for easier grouping in the plot
melted_data = all_data.melt(id_vars=['Bowl'], value_vars=value_vars,
                            var_name='Category', value_name='Count')

custom_palette = ['forestgreen', 'salmon', 'red',]  # Red, Blue, Green, Yellow

# Create the plot
plt.figure(figsize=(10, 6))
sns.barplot(
    data=melted_data,
    x='Bowl',
    y='Count',
    hue='Category',
    errorbar=('ci', 68),       # SEM
    palette=custom_palette,        # Placeholder palette; we'll override this
    alpha=0.6              # Slight transparency for bars
)


# Scatter points (black swarmplot)
sns.swarmplot(
    data=melted_data,
    x='Bowl',
    y='Count',
    hue='Category',
    dodge=True,      # Adjust position to match boxplot
    color='black',   # Black scatter points
    alpha=0.7,       # Slight transparency
    legend=False,
    size=5           # Adjust scatter size
)

# Adjust legend
plt.legend(title='Category', bbox_to_anchor=(1.05, 1), loc='upper left')

# Add labels and title
#plt.title('Boxplot with Swarmplot: Success, Dropped, and Failure Counts by Bowl', fontsize=14)
plt.xlabel('Bowl', fontsize=12)
plt.ylabel('Performance (%)', fontsize=12)

# Adjust legend for barplot with colors matching the barplot palette
handles, labels = plt.gca().get_legend_handles_labels()
plt.legend(
    handles=handles[:3],
    labels=labels[:3],
    #title='Category',
    loc='upper left',  # Position the legend inside the plot
    bbox_to_anchor=(0, 1),  # Adjust position inside the plot
    frameon=False,  # Remove legend border
    fontsize=12     # Font size for legend
)

# Remove gridlines
sns.despine()
plt.grid(False)

# Set y-axis limits
plt.ylim(0, 100)
plt.title("Harmaline")

# Final adjustments
plt.tight_layout()


plt.show()


# Perform the Two-Way ANOVA (with interaction between Bowl and Category)
model = ols('Count ~ C(Bowl) * C(Category)', data=melted_data).fit()
anova_table = sm.stats.anova_lm(model, typ=2)

print("ANOVA Results:")
print(anova_table)

# If the p-value for interaction is significant, perform Tukey's HSD test
if anova_table['PR(>F)']['C(Bowl):C(Category)'] < 0.05:
    print("\nSignificant interaction between Bowl and Category, performing post-hoc test (Tukey HSD).")

    # Perform Tukey's HSD test
    tukey_result = pairwise_tukeyhsd(endog=melted_data['Count'],
                                     groups=melted_data['Bowl'].astype(str) + "_" + melted_data['Category'].astype(str),
                                     alpha=0.05)

    print("\nTukey HSD Post-hoc Test Results:")
    print(tukey_result.summary())
else:
    print("\nNo significant interaction between Bowl and Category. No post-hoc test needed.")

"""# Figure 5a comparison of success"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import gspread
from gspread_dataframe import get_as_dataframe
from google.colab import auth
from google.auth.transport.requests import Request
from google.oauth2.service_account import Credentials

plt.rcParams['pdf.fonttype'] = 42 #to work with in illustrator
plt.rcParams['ps.fonttype'] = 42 #to work with in illustrator

# Load data from the first worksheet (finemotorupdated)
worksheet1 = gc.open("finemotorupdated").worksheet('AllData')
df1 = get_as_dataframe(worksheet1, evaluate_formulas=True)

# Clean data: Drop rows with NaN values in 'Rat' column and strip whitespace
df1 = df1.dropna(subset=['Rat'])
df1['Rat'] = df1['Rat'].str.strip()

# Load data from the second worksheet (harmalineupdated)
worksheet2 = gc.open("harmalineupdated").worksheet('Sheet1')
df2 = get_as_dataframe(worksheet2, evaluate_formulas=True)

# Clean data: Drop rows with NaN values in 'Rat' column and strip whitespace
df2 = df2.dropna(subset=['Rat'])
df2['Rat'] = df2['Rat'].str.strip()

# Merge both dataframes with an indicator for the dataset
df1['Condition'] = 'Baseline'  # Rename Pilot to Baseline
df2['Condition'] = 'Harmaline'
df_combined = pd.concat([df1, df2], ignore_index=True)

# Melt data to long format
df_long = df_combined.melt(id_vars=['Condition', 'Bowl', 'Rat'], value_vars=['SuccessPerformance'],
                           var_name='Outcome', value_name='Outcome_Count')

# Filter for Success only
df_long_success = df_long[df_long['Outcome'] == 'SuccessPerformance']

# Multiply the success performance by 100
df_long_success['Outcome_Count'] = df_long_success['Outcome_Count'] * 100

# Enforce the correct order for 'Bowl'
bowl_order = ['plain', 'less', 'plinko']
df_long_success['Bowl'] = pd.Categorical(df_long_success['Bowl'], categories=bowl_order, ordered=True)

# Calculate the average performance (Success Count) per rat per bowl (one value per rat per bowl)
avg_per_rat_per_bowl = df_long_success.groupby(['Rat', 'Bowl', 'Condition'], as_index=False)['Outcome_Count'].mean()

# Calculate the mean and SEM for each 'Condition' and 'Bowl'
mean_data = df_long_success.groupby(['Condition', 'Bowl'])['Outcome_Count'].mean().reset_index(name='Outcome_Count_mean')
sem_data = df_long_success.groupby(['Condition', 'Bowl'])['Outcome_Count'].sem().reset_index(name='Outcome_Count_sem')

# Merge mean and SEM data for plotting
mean_data = pd.merge(mean_data, sem_data, on=['Condition', 'Bowl'])

# Create a figure for the bar plot with swarmplot overlay
fig, ax = plt.subplots(figsize=(10, 6))

# Plot the bar plot with the mean data, separate bars for each condition within each bowl
sns.barplot(x='Bowl', y='Outcome_Count_mean', hue='Condition', data=mean_data, ax=ax,
            palette={'Baseline': 'white', 'Harmaline': 'white'}, errorbar=('ci', 68), edgecolor='black',alpha=0.6)

# Overlay the scatter plot with custom styling
sns.swarmplot(x='Bowl', y='Outcome_Count', hue='Condition', data=avg_per_rat_per_bowl, ax=ax,
              palette={'Baseline': 'black', 'Harmaline': 'dodgerblue'}, dodge=True, edgecolor='black', size=6)

# Add SEM error bars
for i, row in mean_data.iterrows():
    x = bowl_order.index(row['Bowl']) + (-0.2 if row['Condition'] == 'Baseline' else 0.2)
    ax.errorbar(x=x, y=row['Outcome_Count_mean'], yerr=row['Outcome_Count_sem'], fmt='none',
                capsize=0, color='black', elinewidth=2)

# Remove the legend
ax.get_legend().remove()

# Add text at the top-left of the plot
ax.text(0.02, 0.98, 'Baseline', color='black', fontsize=12, transform=ax.transAxes)
ax.text(0.02, 0.94, 'Harmaline', color='dodgerblue', fontsize=12, transform=ax.transAxes)

# Set plot labels and title
ax.set_xlabel('Bowl Type')
ax.set_ylabel('Success (%)')
ax.set_title('Baseline vs Harmaline')

# Remove grid lines
sns.despine()
ax.grid(False)
plt.ylim(0, 100)

# Adjust layout to ensure proper alignment
plt.tight_layout()


plt.show()

# Two-Way Repeated Measures ANOVA using pingouin
anova_results = pg.rm_anova(dv='Outcome_Count', within=['Condition', 'Bowl'], subject='Rat', data=df_long_success)

# Print results
print(anova_results)

# If the interaction is significant, perform post-hoc tests
if anova_results['p-unc'][2] < 0.05:  # Interaction term: Condition * Bowl
    print("\nSignificant interaction between Condition and Bowl, performing post-hoc tests.")
    posthoc_results = pg.pairwise_ttests(dv='Outcome_Count', within='Condition', between='Bowl', subject='Rat', data=df_long_success, padjust='bonf')
    print(posthoc_results)
else:
    print("\nNo significant interaction between Condition and Bowl. No post-hoc tests needed.")

"""# Figure 5b comparison of Failure"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import gspread
from gspread_dataframe import get_as_dataframe
from google.colab import auth
from google.auth.transport.requests import Request
from google.oauth2.service_account import Credentials

plt.rcParams['pdf.fonttype'] = 42 #to work with in illustrator
plt.rcParams['ps.fonttype'] = 42 #to work with in illustrator

# Load data from the first worksheet (finemotorupdated)
worksheet1 = gc.open("finemotorupdated").worksheet('AllData')
df1 = get_as_dataframe(worksheet1, evaluate_formulas=True)

# Clean data: Drop rows with NaN values in 'Rat' column and strip whitespace
df1 = df1.dropna(subset=['Rat'])
df1['Rat'] = df1['Rat'].str.strip()

# Load data from the second worksheet (harmalineupdated)
worksheet2 = gc.open("harmalineupdated").worksheet('Sheet1')
df2 = get_as_dataframe(worksheet2, evaluate_formulas=True)

# Clean data: Drop rows with NaN values in 'Rat' column and strip whitespace
df2 = df2.dropna(subset=['Rat'])
df2['Rat'] = df2['Rat'].str.strip()

# Merge both dataframes with an indicator for the dataset
df1['Condition'] = 'Baseline'  # Rename Pilot to Baseline
df2['Condition'] = 'Harmaline'
df_combined = pd.concat([df1, df2], ignore_index=True)

# Melt data to long format
df_long = df_combined.melt(id_vars=['Condition', 'Bowl', 'Rat'], value_vars=['Failure'],
                           var_name='Outcome', value_name='Outcome_Count')

# Filter for Success only
df_long_success = df_long[df_long['Outcome'] == 'Failure']


# Enforce the correct order for 'Bowl'
bowl_order = ['plain', 'less', 'plinko']
df_long_success['Bowl'] = pd.Categorical(df_long_success['Bowl'], categories=bowl_order, ordered=True)

# Calculate the average performance (Success Count) per rat per bowl (one value per rat per bowl)
avg_per_rat_per_bowl = df_long_success.groupby(['Rat', 'Bowl', 'Condition'], as_index=False)['Outcome_Count'].mean()

# Calculate the mean and SEM for each 'Condition' and 'Bowl'
mean_data = df_long_success.groupby(['Condition', 'Bowl'])['Outcome_Count'].mean().reset_index(name='Outcome_Count_mean')
sem_data = df_long_success.groupby(['Condition', 'Bowl'])['Outcome_Count'].sem().reset_index(name='Outcome_Count_sem')

# Merge mean and SEM data for plotting
mean_data = pd.merge(mean_data, sem_data, on=['Condition', 'Bowl'])

# Create a figure for the bar plot with swarmplot overlay
fig, ax = plt.subplots(figsize=(10, 6))

# Plot the bar plot with the mean data, separate bars for each condition within each bowl
sns.barplot(x='Bowl', y='Outcome_Count_mean', hue='Condition', data=mean_data, ax=ax,
            palette={'Baseline': 'white', 'Harmaline': 'white'}, errorbar=('ci', 68), edgecolor='black')

# Overlay the scatter plot with custom styling
sns.swarmplot(x='Bowl', y='Outcome_Count', hue='Condition', data=avg_per_rat_per_bowl, ax=ax,
              palette={'Baseline': 'black', 'Harmaline': 'dodgerblue'}, dodge=True, edgecolor='gray', size=6)

# Add SEM error bars
for i, row in mean_data.iterrows():
    x = bowl_order.index(row['Bowl']) + (-0.2 if row['Condition'] == 'Baseline' else 0.2)
    ax.errorbar(x=x, y=row['Outcome_Count_mean'], yerr=row['Outcome_Count_sem'], fmt='none',
                capsize=0, color='black', elinewidth=2)

# Remove the legend
ax.get_legend().remove()

# Add text at the top-left of the plot
ax.text(0.02, 0.98, 'Baseline', color='black', fontsize=12, transform=ax.transAxes)
ax.text(0.02, 0.94, 'Harmaline', color='dodgerblue', fontsize=12, transform=ax.transAxes)

# Set plot labels and title
ax.set_xlabel('Bowl Type')
ax.set_ylabel('Failure (counts)')
ax.set_title('Baseline vs Harmaline')

# Remove grid lines
sns.despine()
ax.grid(False)
plt.ylim(0, 40)

# Adjust layout to ensure proper alignment
plt.tight_layout()


plt.show()

# Two-Way Repeated Measures ANOVA using pingouin
anova_results = pg.rm_anova(dv='Outcome_Count', within=['Condition', 'Bowl'], subject='Rat', data=df_long_success)

# Print results
print(anova_results)

# If the interaction is significant, perform post-hoc tests
if anova_results['p-unc'][2] < 0.05:  # Interaction term: Condition * Bowl
    print("\nSignificant interaction between Condition and Bowl, performing post-hoc tests.")
    posthoc_results = pg.pairwise_ttests(dv='Outcome_Count', within='Condition', between='Bowl', subject='Rat', data=df_long_success, padjust='fdr_bh')
    print(posthoc_results)
else:
    print("\nNo significant interaction between Condition and Bowl. No post-hoc tests needed.")

"""# Figure 6 Total reaches per min"""

import gspread
from gspread_dataframe import get_as_dataframe
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

# Set plot configuration to be compatible with Illustrator
plt.rcParams['pdf.fonttype'] = 42
plt.rcParams['ps.fonttype'] = 42

# Load data from the Google Sheets worksheet
worksheet1 = gc.open("tr per min").worksheet('Sheet1')
data = worksheet1.get_all_values()
df = pd.DataFrame(data[1:], columns=data[0])  # Use the first row as headers

# Print the column names to verify the exact name
print(df.columns)

# Rename column to match expected format (if needed)
df.rename(columns={'Total reaches per min': 'Total Reaches per min'}, inplace=True)
df['Total Reaches per min'] = pd.to_numeric(df['Total Reaches per min'], errors='coerce')

# Ensure the 'Bowl' and 'Treatment' columns have the correct order
df['Bowl'] = pd.Categorical(df['Bowl'], categories=['Plain', 'Less', 'Plinko'], ordered=True)
df['Treatment'] = pd.Categorical(df['Treatment'], categories=['Baseline', 'Harmaline'], ordered=True)

# Calculate the average number of total reaches per bowl per animal
df_avg = df.groupby(['Bowl', 'Treatment', 'Rat'], as_index=False)['Total Reaches per min'].mean()

# Melt the data for easier grouping in the plot
melted_data = df_avg.melt(id_vars=['Bowl', 'Treatment'], value_vars=['Total Reaches per min'],
                      var_name='Category', value_name='Count')
# Create the plot
plt.figure(figsize=(10, 6))
sns.barplot(
    data=melted_data,
    x='Bowl',
    y='Count',
    hue='Treatment',
    errorbar=('ci', 68),  # SEM
    palette={'Baseline': 'white', 'Harmaline': 'white'},  # Custom colors
    edgecolor='black',
    alpha=0.6  # Slight transparency for bars
)

# Scatter points (black swarmplot)
sns.swarmplot(
    data=melted_data,
    x='Bowl',
    y='Count',
    hue='Treatment',
    dodge=True,  # Adjust position to match barplot
    palette={'Baseline': 'black', 'Harmaline': 'dodgerblue'},  # Custom color for scatter points
    alpha=0.7,  # Slight transparency
    legend=False,
    size=5  # Adjust scatter size
)

plt.ylim(0, 10)

# Adjust legend to match the scatterplot colors
plt.legend(bbox_to_anchor=(0.05, 1), loc='upper left', frameon=False, fontsize=12)

# Set plot labels and title
plt.xlabel('Bowl', fontsize=12)
plt.ylabel('Total Reaches (per Minute)', fontsize=12)
plt.title("Reaching Rate", fontsize=14)

# Remove grid lines and axes spines
sns.despine()
plt.grid(False)  # Explicitly remove the grid lines

plt.show()

# Two-Way Repeated Measures ANOVA using pingouin
anova_results = pg.rm_anova(dv='Total Reaches per min', within=['Treatment', 'Bowl'], subject='Rat', data=df)

# Print ANOVA results
print(anova_results)

# If the interaction is significant, perform post-hoc tests
if anova_results['p-unc'][2] < 0.05:  # Interaction term: Treatment * Bowl
    print("\nSignificant interaction between Treatment and Bowl, performing post-hoc tests.")
    posthoc_results = pg.pairwise_ttests(dv='Total Reaches per min', between=['Bowl','Treatment'], subject='Rat', data=df, padjust='fdr_bh')
    print(posthoc_results)
else:
    print("\nNo significant interaction between Treatment and Bowl. No post-hoc tests needed.")

"""# Figure 7 AUC

"""

# Import necessary libraries
import gspread
from google.auth import default
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.metrics import auc
from scipy.stats import ks_2samp, ttest_ind

plt.rcParams['pdf.fonttype'] = 42 #to work with in illustrator
plt.rcParams['ps.fonttype'] = 42 #to work with in illustrator

# Authenticate and connect to Google Sheets
creds, _ = default()
gc = gspread.authorize(creds)

# Load data from the Google Sheet
worksheet = gc.open('mean_point_distance_line_plot_data').worksheet("Sheet1")
data = worksheet.get_all_values()

# Convert the data to a Pandas DataFrame
df = pd.DataFrame(data[1:], columns=data[0])  # Use first row as column headers

# Convert necessary columns to numeric
df['Mean_Point_Distance'] = pd.to_numeric(df['Mean_Point_Distance'])
df['Time'] = pd.to_numeric(df['Time'])

# Calculate z-scores for Mean_Point_Distance
df['Z_Score_Mean_Point_Distance'] = (
    (df['Mean_Point_Distance'] - df['Mean_Point_Distance'].mean()) / df['Mean_Point_Distance'].std()
)

# Calculate AUC for each group
auc_values = df.groupby('Group').apply(
    lambda x: simps(x['Z_Score_Mean_Point_Distance'], x['Time'])
).rename('AUC').reset_index()

# Perform t-test between the two groups
pilot_values = df[df['Group'] == 'Pilot']['Z_Score_Mean_Point_Distance']
harmaline_values = df[df['Group'] == 'Harmaline']['Z_Score_Mean_Point_Distance']
t_stat, p_value = ttest_ind(pilot_values, harmaline_values, equal_var=False)  # Welch's t-test

# Bar plot to compare AUCs
plt.figure(figsize=(8, 6))
plt.bar(auc_values['Group'], auc_values['AUC'], color=['blue', 'orange'], alpha=0.7)
plt.xlabel('Group', fontsize=12)
plt.ylabel('Area Under Curve (AUC)', fontsize=12)
plt.title('Comparison of AUC between Pilot and Harmaline Groups', fontsize=14)
plt.grid(axis='y', linestyle='--', alpha=0.7)

# Remove grid lines and axes spines
sns.despine()
plt.grid(False)  # Explicitly remove the grid lines


# Display AUC values
print(auc_values)

plt.show()

# Display AUC values and t-test results
print("AUC values:")
print(auc_values)
print("\nT-Test Results:")
print(f"T-statistic: {t_stat:.4f}, P-value: {p_value:.4e}")